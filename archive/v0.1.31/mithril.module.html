<!doctype html>
<html>
	<head>
		<title>m.module - Mithril</title>
		<link href="lib/prism/prism.css" rel="stylesheet" />
		<link href="style.css" rel="stylesheet" />
	</head>
	<body>
		<header>
			<nav class="container">
				<a href="index.html" class="logo"><span>&#9675;</span> Mithril</a>
				<a href="getting-started.html">Guide</a>
				<a href="mithril.html">API</a>
				<a href="community.html">Community</a>
				<a href="http://lhorie.github.io/mithril-blog">Learn</a>
				<a href="mithril.min.zip">Download</a>
				<a href="http://github.com/lhorie/mithril.js" target="_blank">Github</a>
			</nav>
		</header>
		<main>
			<section class="content">
				<div class="container">
					<div class="row">
						<div class="col(3,3,12)">
							<h2 id="api">API (v0.1.31)</h2>
							<h3 id="core">Core</h3>
							<ul>
								<li><a href="mithril.html" title="A utility to create virtual elements">m</a></li>
								<li><a href="mithril.module.html" title="Initializes a controller/view pair">m.module</a></li>
								<li><a href="mithril.prop.html" title="A getter-setter utility">m.prop</a></li>
								<li><a href="mithril.withAttr.html" title="A event handler factory utility">m.withAttr</a></li>
							</ul>
							<h3 id="routing">Routing</h3>
							<ul>
								<li><a href="mithril.route.html" title="A routing utility">m.route</a>
									<ul>
										<li><a href="mithril.route.html#defining-routes" title="Defines what routes exist">m.route(rootElement, defaultRoute, routes)</a></li>
										<li><a href="mithril.route.html#redirecting" title="Redirects to a route">m.route(path, params, replaceHistory)</a></li>
										<li><a href="mithril.route.html#reading-current-route" title="Read the current route">m.route()</a></li>
										<li><a href="mithril.route.html#mode-abstraction" title="Routing mode abstraction">m.route(element)</a></li>
										<li><a href="mithril.route.html#mode" title="Whether routing uses location hash, querystring or pathname">m.route.mode</a></li>
										<li><a href="mithril.route.html#param" title="Read an argument from a parameterized route">m.route.param</a></li>
										<li><a href="mithril.route.html#buildQueryString" title="Serialize data into querystring format">m.route.buildQueryString</a></li>
										<li><a href="mithril.route.html#parseQueryString" title="Read an argument from a parameterized route">m.route.parseQueryString</a></li>
									</ul>
								</li>
							</ul>
							<h3 id="data">Data</h3>
							<ul>
								<li><a href="mithril.request.html" title="A high-level AJAX utility">m.request</a></li>
								<li><a href="mithril.deferred.html" title="A Promise factory">m.deferred</a></li>
								<li><a href="mithril.sync.html" title="A Promise aggregator">m.sync</a></li>
							</ul>
							<h3 id="html">HTML</h3>
							<ul>
								<li><a href="mithril.trust.html" title="A method to unescape HTML">m.trust</a></li>
							</ul>
							<h3 id="rendering">Rendering</h3>
							<ul>
								<li><a href="mithril.render.html" title="The lowest level rendering method">m.render</a></li>
								<li><a href="mithril.redraw.html" title="A high-level explicit rendering method">m.redraw</a>
									<ul>
										<li><a href="mithril.redraw.html#strategy" title="A flag that drives the rendering strategy for the next redraw">m.redraw.strategy(strategy)</a></li>
									</ul>
								</li>
								<li><a href="mithril.computation.html" title="Utilities to integrate asynchronous contexts to the rendering system">m.startComputation / m.endComputation</a></li>
							</ul>
							<h3 id="data">Testing</h3>
							<ul>
								<li><a href="mithril.deps.html" title="The dependency injector">m.deps</a></li>
							</ul>
							
							<h2 id="archive">History</h2>
							<ul>
								<li><a href="roadmap.html">Roadmap</a></li>
								<li><a href="change-log.html">Change log</a></li>
							</ul>
						</div>
						<div class="col(9,9,12)">
							<h2 id="m-module">m.module</h2>
<hr>
<ul>
<li><a href="#usage">Usage</a></li>
<li><a href="#unloading-modules">Unloading modules</a></li>
<li><a href="#signature">Signature</a></li>
</ul>
<hr>
<p>A module is an Object with two keys: <code>controller</code> and <code>view</code>. Each of those should point to a Javascript function. Note that the name of both properties should be lower-cased.</p>
<pre><code class="lang-javascript">//a valid module
{controller: function() {}, view: function() {}}
</code></pre>
<p>When using <code>m.module</code>, Mithril instantiates controllers as if they were class constructors. However, controllers may return objects if you want to use that Javascript feature to have more fine-grained control over a controller&#39;s lifecycle.</p>
<p>Conceptually, the easiest way to think of a module is as a logical namespace with which to organize applications. For example, an app might have a dashboard module, a userEditForm module, an autocompleter module, a date formatting module, etc</p>
<p>In the context of single page applications (SPA), a module can often be thought of as the code for a single &quot;page&quot;, i.e. a visual state that is bookmarkable. Module can, however, also represent <em>parts</em> of pages.</p>
<p>Note that a module might have external dependencies and that the dependencies aren&#39;t considered part of the module.</p>
<p>In more complex applications, modules can be nested in a <a href="http://en.wikipedia.org/wiki/Hierarchical_model%E2%80%93view%E2%80%93controller">hierarchical MVC</a> pattern. Nested reusable modules that have views are called <strong>Components</strong>.</p>
<p>Modules and namespaces are often used interchangeably, but namespaces that do not implement the module interface (that is, objects that do not have a property called <code>controller</code> and a property called <code>view</code>) cannot be activated with <code>m.module</code>. For example, a namespace for date formatting utilities could be labeled a &quot;module&quot; (in the generic sense of the word) but it would not contain a view class, and therefore attempting to initialize it via <code>m.module</code> would result in undefined behavior.</p>
<hr>
<h3 id="usage">Usage</h3>
<p>You can make anonymous modules out of existing classes</p>
<pre><code class="lang-javascript">//model object
var dashboardViewModel = {};
dashboardViewModel.init = function() {
    this.greeting = &quot;Hello&quot;;
};

//controller class
var dashboardController = function() {
    dashboardViewModel.init();
};

//view class
var dashboardView = function() {
    return m(&quot;h1&quot;, dashboardViewModel.greeting);
};

//initialize an anonymous module
m.module(document.body, {controller: dashboardController, view: dashboardView});
</code></pre>
<p>Typically, however, modules and namespaces are used interchangeably.</p>
<pre><code class="lang-javascript">//`dashboard` is both a namespace and a module
var dashboard = {}

//view-model
dashboard.vm = {}

//controller
dashboard.controller = function() {
    dashboard.vm.greeting = &quot;Hello&quot;;
};

//view
dashboard.view = function(vm) {
    return m(&quot;h1&quot;, dashboard.vm.greeting);
};

//initialize it
m.module(document.body, dashboard);
</code></pre>
<p>Modules can also be used as components in order to assemble bigger systems. You can <a href="components.html">read more about componentization here</a></p>
<hr>
<h3 id="unloading-modules">Unloading modules</h3>
<p>If a module&#39;s controller implements an instance method called <code>onunload</code>, this method will be called when a new <code>m.module</code> call updates the root DOM element tied to the module in question.</p>
<pre><code class="lang-javascript">var module1 = {};
module1.controller = function() {
    this.onunload = function() {
        console.log(&quot;unloading module 1&quot;);
    };
};
module1.view = function() {};

m.module(document, module1);



var module2 = {};
module2.controller = function() {};
module1.view = function() {};

m.module(document, module2); // logs &quot;unloading module 1&quot;
</code></pre>
<p>This mechanism is useful to clear timers and unsubscribe event handlers. If you have a hierarchy of components, you can recursively call <code>onunload</code> on all the components in the tree or use a <a href="http://microjs.com/#pubsub">pubsub</a> library to unload specific components on demand.</p>
<p>You can also use this event to prevent a module from being unloaded (e.g. to alert a user to save their changes before navigating away from a page)</p>
<pre><code class="lang-javascript">var module1 = {}
module1.controller = function() {
    this.onunload = function(e) {
        if (!confirm(&quot;are you sure you want to leave this page?&quot;)) e.preventDefault()
    }
}
</code></pre>
<p>Normally, calling <code>m.module</code> will return the controller instance for that module, but there&#39;s one corner case: if <code>preventDefault</code> is called from a controller&#39;s <code>onunload</code> method as a result of calling <code>m.module</code>, then the <code>m.module</code> call will not instantiate the new controller, and will return <code>undefined</code>.</p>
<p>To unload a module without loading another module, you can simply call <code>m.module</code> without a module parameter:</p>
<pre><code class="lang-javascript">m.module(rootElement, null);
</code></pre>
<hr>
<h3 id="signature">Signature</h3>
<p><a href="how-to-read-signatures.html">How to read signatures</a></p>
<pre><code class="lang-clike">Object module(DOMElement rootElement, Module module)

where:
    Module :: Object { Controller, void view(Object controllerInstance) }
    Controller :: void controller() | void controller() { prototype: void unload(UnloadEvent e) }
    UnloadEvent :: Object {void preventDefault()}
</code></pre>
<ul>
<li><p><strong>DOMElement rootElement</strong></p>
<p>A DOM element which will contain the view&#39;s template.</p>
</li>
<li><p><strong>Module module</strong></p>
<p>A module is supposed to be an Object with two keys: <code>controller</code> and <code>view</code>. Each of those should point to a Javascript class constructor function</p>
<p>The controller class is instantiated immediately and a reference is returned upon calling <code>m.module</code>.</p>
<p>Once the controller code finishes executing (and this may include waiting for AJAX requests to complete), the view class is instantiated, and the instance of the controller is passed as an argument to the view&#39;s constructor.</p>
<p>Note that controllers can manually instantiate child controllers (since they are simply Javascript constructors), and likewise, views can call child views and manually pass the child controller instances down the the child view constructors. You should avoid instantiating controllers from views, since views can be rendered many times across the lifecycle of a page, and a redraw might wipe out sub-controller data, if it houses any.</p>
<p>This &quot;<a href="https://en.wikipedia.org/wiki/Turtles_all_the_way_down">turtles all the way down</a>&quot; approach is the heart of Mithril&#39;s component system.</p>
<p>Components are nothing more than decoupled classes that can be dynamically brought together as required. This permits the swapping of implementations at a routing level (for example, if implementing widgetized versions of existing components), and class dependency hierarchies can be structurally organized to provide uniform interfaces (for unit tests, for example).</p>
</li>
<li><p><strong>returns Object controllerInstance</strong></p>
<p>An instance of the controller constructor</p>
</li>
</ul>

						</div>
					</div>
				</div>
			</section>
		</main>
		<footer>
			<div class="container">
				Released under the <a href="http://opensource.org/licenses/MIT" target="_blank">MIT license</a>
				<br />&copy; 2014 Leo Horie
			</div>
		</footer>
		<script src="lib/prism/prism.js"></script>
	</body>
</html>
