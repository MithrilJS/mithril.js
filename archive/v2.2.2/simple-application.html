<!doctype html>
<html lang=en>
<head>
<meta charset=UTF-8>
<title>Mithril.js</title>
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel=stylesheet>
<link href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/themes/prism.min.css rel=stylesheet>
<link href=style.css rel=stylesheet>
<link rel=icon type=image/png sizes=32x32 href=favicon.png>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="A complete walkthrough tutorial for building your first simple application in Mithril.js, from beginning to end">
</head>
<body onload="window.requestAnimationFrame(function(){document.getElementById('archive-docs').selectedIndex = 0})" /* handle back navigation */>
<header>
<section>
<a class=hamburger href=javascript:;>â‰¡</a>
<h1><img src=logo.svg> Mithril <select id=archive-docs onchange="location.href='archive/' + this.value + '/index.html'"><option>v2.2.2<option>v2.2.1<option>v2.2.0<option>v2.0.4<option>v2.0.3<option>v2.0.2<option>v2.0.1<option>v2.0.0-rc.9<option>v2.0.0-rc.8<option>v2.0.0-rc.7<option>v2.0.0-rc.6<option>v2.0.0-rc.5<option>v2.0.0-rc.4<option>v2.0.0-rc.3<option>v2.0.0-rc.1<option>v2.0.0-rc.0<option>v1.1.7<option>v1.1.6<option>v1.1.5<option>v1.1.4<option>v1.1.3<option>v1.1.2<option>v1.1.1<option>v1.1.0-rc.1<option>v1.1.0<option>v1.0.1<option>v1.0.0<option>v0.2.5<option>v0.2.4<option>v0.2.3<option>v0.2.2-rc.1<option>v0.2.1<option>v0.2.0<option>v0.1.9<option>v0.1.8<option>v0.1.7<option>v0.1.6<option>v0.1.5<option>v0.1.4<option>v0.1.34<option>v0.1.33<option>v0.1.32<option>v0.1.31<option>v0.1.30<option>v0.1.3<option>v0.1.29<option>v0.1.28<option>v0.1.27<option>v0.1.26<option>v0.1.25<option>v0.1.24<option>v0.1.23<option>v0.1.22<option>v0.1.21<option>v0.1.20<option>v0.1.2<option>v0.1.19<option>v0.1.18<option>v0.1.17<option>v0.1.16<option>v0.1.15<option>v0.1.14<option>v0.1.13<option>v0.1.12<option>v0.1.11<option>v0.1.10<option>v0.1.1<option>v0.1</select></h1>
<nav>
<a href=index.html>Guide</a>
<a href=api.html>API</a>
<a href=https://mithril.zulipchat.com/ >Chat</a>
<a href=https://github.com/MithrilJS/mithril.js>GitHub</a>
</nav>
</section>
</header>
<main>
<section>
<h1 id=simple-application><a href=#simple-application>Simple application</a></h1>
<ul>
<li>Getting Started<ul>
<li><a href=index.html>Introduction</a></li>
<li><a href=installation.html>Installation</a></li>
<li><strong><a href=simple-application.html>Tutorial</a></strong></li>
<li><a href=learning-mithril.html>Learning Resources</a></li>
<li><a href=support.html>Getting Help</a></li>
</ul>
</li>
<li>Resources<ul>
<li><a href=jsx.html>JSX</a></li>
<li><a href=es6.html>ES6+ on legacy browsers</a></li>
<li><a href=animation.html>Animation</a></li>
<li><a href=testing.html>Testing</a></li>
<li><a href=examples.html>Examples</a></li>
<li><a href=integrating-libs.html>3rd Party Integration</a></li>
<li><a href=paths.html>Path Handling</a></li>
</ul>
</li>
<li>Key concepts<ul>
<li><a href=vnodes.html>Vnodes</a></li>
<li><a href=components.html>Components</a></li>
<li><a href=lifecycle-methods.html>Lifecycle methods</a></li>
<li><a href=keys.html>Keys</a></li>
<li><a href=autoredraw.html>Autoredraw system</a></li>
</ul>
</li>
<li>Social<ul>
<li><a href=https://github.com/MithrilJS/mithril.js/wiki/JOBS>Mithril.js Jobs</a></li>
<li><a href=contributing.html>How to contribute</a></li>
<li><a href=credits.html>Credits</a></li>
<li><a href=code-of-conduct.html>Code of Conduct</a></li>
</ul>
</li>
<li>Misc<ul>
<li><a href=framework-comparison.html>Framework comparison</a></li>
<li><a href=changelog.html>Change log/Migration</a></li>
<li><a href=https://mithril.js.org/archive/v1.1.7/ >v1 Documentation</a></li>
<li><a href=https://mithril.js.org/archive/v0.2.5/ >v0.2 Documentation</a></li>
</ul>
</li>
</ul>
<p>Let&#39;s develop a simple application that shows off how to do most of the major things you would need to deal with while using Mithril.</p>
<p><em>An interactive example of the end result can be seen <a href="https://flems.io/#0=N4IgzgpgNhDGAuEAmIBcICqkBOBZA9ktAHQBWYIANCAGYCWMFqA2qAHYCGAthGpjgSJQyFarHxtEkvgDcO2AARYIigLwLgAHTYLdCqHTDxUC5gF1K2vfvwckAGUPGFNAK5sEdCQAoAlBqtrPWwIeFdsHS5iEIBHVwgjby0dINSeeAALQhNNEABxAFEAFVzLFNTrcKgckAz4eAAHMFQAehaQrgBaEKNOjga6YgyVfABrV36G4nEuFv66FtccMFLAir0AdzpMgGEQokk6DihmhXhseLL1gF9fNaDiTIg2bzcPeC8XntcoeH9k9bWZTYYgGIwKdTfX7EJAceAce7WW73a5le6wcIhSQmYCo+5QWxIExvTw+OhIf6I4KhcKRaIQOIJeBJKlpUJZIkKXKFEpUVlBKo1OqNZptDrdJl9AZDEbjSbTfCzeaLZYtXIKADUCnJV0Bui2u32zw+x1O50u-OR5QeTxeJI+PihfwC1vWwOmmONEIUTstd2teLY9zAHBkEGJ7lJL0prupYQiCiisXiiQBesT7OyXJAAAUMLzdXrBdnhU1Wu0IF0evApYNhtgxhMGlMZnMBiqVGA1SBNUocB7sFj4MQdfzrAAjQgATxM7oxg+NhcBBoye2QxqOJxM5ogS6R-qR2mu2io4GgcAdbCYIAAjKgbwBmECo9jcXjoYGOIwiU-iSTG2R5D7FQv3gb0010CQ6DYbZZ37Ak7FApcZDoCANgjd5Pj8F11hCeNIm8XJiCWFROjBeBSmAkFyOILh+leSNL28EjsBjdMfRpBMuG8JN8FcRBiEcNhRkoDQMhCGgahaZBtm7XsWJHJBRNgKAODAU4AHIWLIpxOm2SsNNRBQFPobAjAAOTfXt1XVLUFNUiy3wPCpbmc3RjzYDzn0oV8eD4YEADF8GwKJyF-CQpHgQDFEC4KuHA+4oJg5x7SwmQ2EICB-ndBCkG8dLMuIOFzjARTfEDawULQjCo2wiCgjw2lE0I2g4so+r2IkMBXHHLhYJcRisKynD2IqCBiAaEIw0kAARCAaA4H5mTc0agX7EMwz8McXO29zROYXbmtyVTxxIE7oEo3IAroMywM4Hhcl8PcKm43JoIafiRzYD74GYeApwaCBVEQAAPeAzGYBpVNgCAsigIhsFUa7boUe6IDMdrDusJKfpqpjhuAOdPUkYhTMcnhvXG+FsAAc1CYg5CgeIKtWhRGfiOCVAHIdSZu8mIEO25nrSFrzuEMXLpAew1Lut9HuFoJXpAd7PpV36oY4GG4YR1RpfBNGMaoEbVpx-i8aG7L+3nHmHPgSyKfUKn5Dp4d2YgFnVrdzmQWt41QRl+2BdjVIhcOpXx34+AJGICP6gkP6AaB7reu2Q3RNyABlUMBZAJ7+TMFaPK8l8QDRvhpanPjhzCsQIoA9A5EUCuq4S60qvQgbMJ8AqiDYipGq4lq6Og-3K-4yiDuDxWWs4GRaOeVwJ6xvRuN4-jxqEkTjdZ8T5pMDSWnIjTl727NgRWXPDoLhXrCVyAo0onvxtgDIGCQLEVusAuUSPE8S7L9A8oa4gD-JFPga8BKTXmnQEG3oNIAGJj5sAgRAbwSB8AYh4CTScSApzpxAIfJwmNrS5EIUYXIOJ+RYgRubHwfc9QDwIs3fioluKficL4T+egPJIiXKQmS8AWioHJBQ7e1hqEqFoS8J+9DASMOasw+ArDvCxRCqJJ+RV6hmU4ZaFEZQrTeV8u+EA0x1LhX-NIdAOC8EKC+j9USMdI4SBGjQCKJgMohWOAoG8AA2BosCABqKhYScAANyBDorTaCJgABMAAGfx4TPLaG0KPFuaZIk02id4hJsDFpRySboOiINOhbCQJkEwN44nVMSb-IMbB55sFcCNTJ2S4kKHaQ+XJSSPKpO0uREa5FOhGCnDAdxEgICFMTM7NpHScm1JSA0OwSBoI0xMHEnpKSGn9N0vpeKaZxya1GDTBs7hOTwIWpcjgUzJzYBod4-xCgwD4AMEgBQ8CkCfKmeIAk2ATDwIfICqZKywAaxnAoccBJYCjCma0tg6y5k3gWboJZnzVkmAAByPJvAAVmRWcCAYNOhEHENgOEnxxlsEmXUvpOAdK9D2agLIYZFBplBjWElwVyUSBMGclQBgqWbPqf7U6UARogrBSYSFGCYURJmfCuZ7S8UgyFaktWI1bn3KRbA55rz3mfKQDc4KCNuh2DoEsEwD58WThKWAOgAAvdFELjWkRtcCwwkqIVQtlSkOFCL2lVPxailZbA1nzNgbi-FZSKk5LiQAUlVQ02OUcdAHKOScvibBzkQBzUau5kiHk6peeSfVXzAiatImSlZFqFBWpVYEH5wV-mAofO60FqlwXQQFRATo0roWwvlf68NUzg1OsDRG5VUz2XErgFyy8lLqXJOFcmnlzKVAavTacrN-yIAYt3buoVz4LAgAFaMJgrBS5vnAdscSDBTxVD4KWUUixvrHIVLMPqmRsAMAAAIxOIHE4gAAWFon7b3CD6g04B-1AZ8DALAb9DQorXDMNcIAA">here</a></em></p>
<p>First let&#39;s create an entry point for the application. Create a file <code>index.html</code>:</p>
<pre><code class=language-html>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot; /&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;
        &lt;title&gt;My Application&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script src=&quot;bin/app.js&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>The <code>&lt;!doctype html&gt;</code> line indicates this is an HTML 5 document. The first <code>charset</code> meta tag indicates the encoding of the document and the <code>viewport</code> meta tag dictates how mobile browsers should scale the page. The <code>title</code> tag contains the text to be displayed on the browser tab for this application, and the <code>script</code> tag indicates what is the path to the JavaScript file that controls the application.</p>
<p>We could create the entire application in a single JavaScript file, but doing so would make it difficult to navigate the codebase later on. Instead, let&#39;s split the code into <em>modules</em>, and assemble these modules into a <em>bundle</em> <code>bin/app.js</code>.</p>
<p>There are many ways to setup a bundler tool, but most are distributed via npm. In fact, most modern JavaScript libraries and tools are distributed that way, including Mithril. To download npm, <a href=https://nodejs.org/en/ >install Node.js</a>; npm is installed automatically with it. Once you have Node.js and npm installed, open the command line and run this command:</p>
<pre><code class=language-bash>npm init -y
</code></pre>
<p>If npm is installed correctly, a file <code>package.json</code> will be created. This file will contain a skeleton project meta-description file. Feel free to edit the project and author information in this file.</p>
<hr>
<p>To install Mithril.js, follow the instructions in the <a href=installation.html>installation</a> page. Once you have a project skeleton with Mithril.js installed, we are ready to create the application.</p>
<p>Let&#39;s start by creating a module to store our state. Let&#39;s create a file called <code>src/models/User.js</code></p>
<pre><code class=language-javascript>// src/models/User.js
var User = {
    list: []
}

module.exports = User
</code></pre>
<p>Now let&#39;s add code to load some data from a server. To communicate with a server, we can use Mithril.js&#39; XHR utility, <code>m.request</code>. First, we include Mithril.js in the module:</p>
<pre><code class=language-javascript>// src/models/User.js
var m = require(&quot;mithril&quot;)

var User = {
    list: []
}

module.exports = User
</code></pre>
<p>Next we create a function that will trigger an XHR call. Let&#39;s call it <code>loadList</code></p>
<pre><code class=language-javascript>// src/models/User.js
var m = require(&quot;mithril&quot;)

var User = {
    list: [],
    loadList: function() {
        // TODO: make XHR call
    }
}

module.exports = User
</code></pre>
<p>Then we can add an <code>m.request</code> call to make an XHR request. For this tutorial, we&#39;ll make XHR calls to the <a href=https://rem-rest-api.herokuapp.com/ >REM</a> API, a mock REST API designed for rapid prototyping. This API returns a list of users from the <code>GET https://rem-rest-api.herokuapp.com/api/users</code> endpoint. Let&#39;s use <code>m.request</code> to make an XHR request and populate our data with the response of that endpoint.</p>
<p><em>Note: third-party cookies may have to be enabled for the REM endpoint to work.</em></p>
<pre><code class=language-javascript>// src/models/User.js
var m = require(&quot;mithril&quot;)

var User = {
    list: [],
    loadList: function() {
        return m.request({
            method: &quot;GET&quot;,
            url: &quot;https://rem-rest-api.herokuapp.com/api/users&quot;,
            withCredentials: true,
        })
        .then(function(result) {
            User.list = result.data
        })
    },
}

module.exports = User
</code></pre>
<p>The <code>method</code> option is an <a href=https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods>HTTP method</a>. To retrieve data from the server without causing side-effects on the server, we need to use the <code>GET</code> method. The <code>url</code> is the address for the API endpoint. The <code>withCredentials: true</code> line indicates that we&#39;re using cookies (which is a requirement for the REM API).</p>
<p>The <code>m.request</code> call returns a Promise that resolves to the data from the endpoint. By default, Mithril.js assumes a HTTP response body are in JSON format and automatically parses it into a JavaScript object or array. The <code>.then</code> callback runs when the XHR request completes. In this case, the callback assigns the <code>result.data</code> array to <code>User.list</code>.</p>
<p>Notice we also have a <code>return</code> statement in <code>loadList</code>. This is a general good practice when working with Promises, which allows us to register more callbacks to run after the completion of the XHR request.</p>
<p>This simple model exposes two members: <code>User.list</code> (an array of user objects), and <code>User.loadList</code> (a method that populates <code>User.list</code> with server data).</p>
<hr>
<p>Now, let&#39;s create a view module so that we can display data from our User model module.</p>
<p>Create a file called <code>src/views/UserList.js</code>. First, let&#39;s include Mithril.js and our model, since we&#39;ll need to use both:</p>
<pre><code class=language-javascript>// src/views/UserList.js
var m = require(&quot;mithril&quot;)
var User = require(&quot;../models/User&quot;)
</code></pre>
<p>Next, let&#39;s create a Mithril.js component. A component is simply an object that has a <code>view</code> method:</p>
<pre><code class=language-javascript>// src/views/UserList.js
var m = require(&quot;mithril&quot;)
var User = require(&quot;../models/User&quot;)

module.exports = {
    view: function() {
        // TODO add code here
    }
}
</code></pre>
<p>By default, Mithril.js views are described using <a href=hyperscript.html>hyperscript</a>. Hyperscript offers a terse syntax that can be indented more naturally than HTML for complex tags, and since its syntax is just JavaScript, it&#39;s possible to leverage a lot of JavaScript tooling ecosystem. For example:</p>
<ul>
<li>You can use <a href=es6.html>Babel</a> to transpile ES6+ to ES5 for IE and to transpile <a href=jsx.html>JSX</a> (an inline HTML-like syntax extension) to appropriate hyperscript calls.</li>
<li>You can use <a href=https://eslint.org/ >ESLint</a> for easy linting with no special plugins.</li>
<li>You can use <a href=https://github.com/terser-js/terser>Terser</a> or <a href=https://github.com/mishoo/UglifyJS2>UglifyJS</a> (ES5 only) to minify your code easily.</li>
<li>You can use <a href=https://github.com/istanbuljs/nyc>Istanbul</a> for code coverage.</li>
<li>You can use <a href=https://www.typescriptlang.org/ >TypeScript</a> for easy code analysis. (There are <a href=https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/mithril>community-supported type definitions available</a>, so you don&#39;t need to roll your own.)</li>
</ul>
<p>Let&#39;s start off with hyperscript and create a list of items. Hyperscript is the idiomatic way to use Mithril.js, but <a href=jsx.html>JSX</a> works pretty similarly.</p>
<pre><code class=language-javascript>// src/views/UserList.js
var m = require(&quot;mithril&quot;)
var User = require(&quot;../models/User&quot;)

module.exports = {
    view: function() {
        return m(&quot;.user-list&quot;)
    }
}
</code></pre>
<p>The <code>&quot;.user-list&quot;</code> string is a CSS selector, and as you would expect, <code>.user-list</code> represents a class. When a tag is not specified, <code>div</code> is the default. So this view is equivalent to <code>&lt;div class=&quot;user-list&quot;&gt;&lt;/div&gt;</code>.</p>
<p>Now, let&#39;s reference the list of users from the model we created earlier (<code>User.list</code>) to dynamically loop through data:</p>
<pre><code class=language-javascript>// src/views/UserList.js
var m = require(&quot;mithril&quot;)
var User = require(&quot;../models/User&quot;)

module.exports = {
    view: function() {
        return m(&quot;.user-list&quot;, User.list.map(function(user) {
            return m(&quot;.user-list-item&quot;, user.firstName + &quot; &quot; + user.lastName)
        }))
    }
}
</code></pre>
<p>Since <code>User.list</code> is a JavaScript array, and since hyperscript views are just JavaScript, we can loop through the array using the <code>.map</code> method. This creates an array of vnodes that represents a list of <code>div</code>s, each containing the name of a user.</p>
<p>The problem, of course, is that we never called the <code>User.loadList</code> function. Therefore, <code>User.list</code> is still an empty array, and thus this view would render a blank page. Since we want <code>User.loadList</code> to be called when we render this component, we can take advantage of component <a href=lifecycle-methods.html>lifecycle methods</a>:</p>
<pre><code class=language-javascript>// src/views/UserList.js
var m = require(&quot;mithril&quot;)
var User = require(&quot;../models/User&quot;)

module.exports = {
    oninit: User.loadList,
    view: function() {
        return m(&quot;.user-list&quot;, User.list.map(function(user) {
            return m(&quot;.user-list-item&quot;, user.firstName + &quot; &quot; + user.lastName)
        }))
    }
}
</code></pre>
<p>Notice that we added an <code>oninit</code> method to the component, which references <code>User.loadList</code>. This means that when the component initializes, User.loadList will be called, triggering an XHR request. When the server returns a response, <code>User.list</code> gets populated.</p>
<p>Also notice we <strong>didn&#39;t</strong> do <code>oninit: User.loadList()</code> (with parentheses at the end). The difference is that <code>oninit: User.loadList()</code> calls the function once and immediately, but <code>oninit: User.loadList</code> only calls that function when the component renders. This is an important difference and a common pitfall for developers new to JavaScript: calling the function immediately means that the XHR request will fire as soon as the source code is evaluated, even if the component never renders. Also, if the component is ever recreated (through navigating back and forth through the application), the function won&#39;t be called again as expected.</p>
<hr>
<p>Let&#39;s render the view from the entry point file <code>src/index.js</code> we created earlier:</p>
<pre><code class=language-javascript>// src/index.js
var m = require(&quot;mithril&quot;)

var UserList = require(&quot;./views/UserList&quot;)

m.mount(document.body, UserList)
</code></pre>
<p>The <code>m.mount</code> call renders the specified component (<code>UserList</code>) into a DOM element (<code>document.body</code>), erasing any DOM that was there previously. Opening the HTML file in a browser should now display a list of person names.</p>
<hr>
<p>Right now, the list looks rather plain because we have not defined any styles. So let&#39;s add a few of them. Let&#39;s first create a file called <code>styles.css</code> and include it in the <code>index.html</code> file:</p>
<pre><code class=language-html>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot; /&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;
        &lt;title&gt;My Application&lt;/title&gt;
        &lt;link href=&quot;styles.css&quot; rel=&quot;stylesheet&quot; /&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script src=&quot;bin/app.js&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Now we can style the <code>UserList</code> component:</p>
<pre><code class=language-css>.user-list {
    list-style: none;
    margin: 0 0 10px;
    padding: 0;
}

.user-list-item {
    background: #fafafa;
    border: 1px solid #ddd;
    color: #333;
    display: block;
    margin: 0 0 1px;
    padding: 8px 15px;
    text-decoration: none;
}

.user-list-item:hover {
    text-decoration: underline;
}
</code></pre>
<p>Reloading the browser window now should display some styled elements.</p>
<hr>
<p>Let&#39;s add routing to our application.</p>
<p>Routing means binding a screen to a unique URL, to create the ability to go from one &quot;page&quot; to another. Mithril.js is designed for Single Page Applications, so these &quot;pages&quot; aren&#39;t necessarily different HTML files in the traditional sense of the word. Instead, routing in Single Page Applications retains the same HTML file throughout its lifetime, but changes the state of the application via JavaScript. Client side routing has the benefit of avoiding flashes of blank screen between page transitions, and can reduce the amount of data being sent down from the server when used in conjunction with an web service oriented architecture (i.e. an application that downloads data as JSON instead of downloading pre-rendered chunks of verbose HTML).</p>
<p>We can add routing by changing the <code>m.mount</code> call to a <code>m.route</code> call:</p>
<pre><code class=language-javascript>// src/index.js
var m = require(&quot;mithril&quot;)

var UserList = require(&quot;./views/UserList&quot;)

m.route(document.body, &quot;/list&quot;, {
    &quot;/list&quot;: UserList
})
</code></pre>
<p>The <code>m.route</code> call specifies that the application will be rendered into <code>document.body</code>. The <code>&quot;/list&quot;</code> argument is the default route. That means the user will be redirected to that route if they land in a route that does not exist. The <code>{&quot;/list&quot;: UserList}</code> object declares a map of existing routes, and what components each route resolves to.</p>
<p>Refreshing the page in the browser should now append <code>#!/list</code> to the URL to indicate that routing is working. Since that route render UserList, we should still see the list of people on screen as before.</p>
<p>The <code>#!</code> snippet is known as a hashbang, and it&#39;s a commonly used string for implementing client-side routing. It&#39;s possible to configure this string it via <a href=route.html#mrouteprefix><code>m.route.prefix</code></a>. Some configurations require supporting server-side changes, so we&#39;ll just continue using the hashbang for the rest of this tutorial.</p>
<hr>
<p>Let&#39;s add another route to our application for editing users. First let&#39;s create a module called <code>views/UserForm.js</code></p>
<pre><code class=language-javascript>// src/views/UserForm.js

module.exports = {
    view: function() {
        // TODO implement view
    }
}
</code></pre>
<p>Then we can <code>require</code> this new module from <code>src/index.js</code></p>
<pre><code class=language-javascript>// src/index.js
var m = require(&quot;mithril&quot;)

var UserList = require(&quot;./views/UserList&quot;)
var UserForm = require(&quot;./views/UserForm&quot;)

m.route(document.body, &quot;/list&quot;, {
    &quot;/list&quot;: UserList
})
</code></pre>
<p>And finally, we can create a route that references it:</p>
<pre><code class=language-javascript>// src/index.js
var m = require(&quot;mithril&quot;)

var UserList = require(&quot;./views/UserList&quot;)
var UserForm = require(&quot;./views/UserForm&quot;)

m.route(document.body, &quot;/list&quot;, {
    &quot;/list&quot;: UserList,
    &quot;/edit/:id&quot;: UserForm,
})
</code></pre>
<p>Notice that the new route has a <code>:id</code> in it. This is a route parameter; you can think of it as a wild card; the route <code>/edit/1</code> would resolve to <code>UserForm</code> with an <code>id</code> of <code>&quot;1&quot;</code>. <code>/edit/2</code> would also resolve to <code>UserForm</code>, but with an <code>id</code> of <code>&quot;2&quot;</code>. And so on.</p>
<p>Let&#39;s implement the <code>UserForm</code> component so that it can respond to those route parameters:</p>
<pre><code class=language-javascript>// src/views/UserForm.js
var m = require(&quot;mithril&quot;)

module.exports = {
    view: function() {
        return m(&quot;form&quot;, [
            m(&quot;label.label&quot;, &quot;First name&quot;),
            m(&quot;input.input[type=text][placeholder=First name]&quot;),
            m(&quot;label.label&quot;, &quot;Last name&quot;),
            m(&quot;input.input[placeholder=Last name]&quot;),
            m(&quot;button.button[type=submit]&quot;, &quot;Save&quot;),
        ])
    }
}
</code></pre>
<p>And let&#39;s add some more styles to <code>styles.css</code>:</p>
<pre><code class=language-css>/* styles.css */
body, .input, .button {
    font: normal 16px Verdana;
    margin: 0;
}

.user-list {
    list-style: none;
    margin: 0 0 10px;
    padding: 0;
}

.user-list-item {
    background: #fafafa;
    border: 1px solid #ddd;
    color: #333;
    display: block;
    margin: 0 0 1px;
    padding: 8px 15px;
    text-decoration: none;
}

.user-list-item:hover {
    text-decoration: underline;
}

.label {
    display: block;
    margin: 0 0 5px;
}

.input {
    border: 1px solid #ddd;
    border-radius: 3px;
    box-sizing: border-box;
    display: block;
    margin: 0 0 10px;
    padding: 10px 15px;
    width: 100%;
}

.button {
    background: #eee;
    border: 1px solid #ddd;
    border-radius: 3px;
    color: #333;
    display: inline-block;
    margin: 0 0 10px;
    padding: 10px 15px;
    text-decoration: none;
}

.button:hover {
    background: #e8e8e8;
}
</code></pre>
<p>Right now, this component does nothing to respond to user events. Let&#39;s add some code to our <code>User</code> model in <code>src/models/User.js</code>. This is how the code is right now:</p>
<pre><code class=language-javascript>// src/models/User.js
var m = require(&quot;mithril&quot;)

var User = {
    list: [],
    loadList: function() {
        return m.request({
            method: &quot;GET&quot;,
            url: &quot;https://rem-rest-api.herokuapp.com/api/users&quot;,
            withCredentials: true,
        })
        .then(function(result) {
            User.list = result.data
        })
    },
}

module.exports = User
</code></pre>
<p>Let&#39;s add code to allow us to load a single user</p>
<pre><code class=language-javascript>// src/models/User.js
var m = require(&quot;mithril&quot;)

var User = {
    list: [],
    loadList: function() {
        return m.request({
            method: &quot;GET&quot;,
            url: &quot;https://rem-rest-api.herokuapp.com/api/users&quot;,
            withCredentials: true,
        })
        .then(function(result) {
            User.list = result.data
        })
    },

    current: {},
    load: function(id) {
        return m.request({
            method: &quot;GET&quot;,
            url: &quot;https://rem-rest-api.herokuapp.com/api/users/&quot; + id,
            withCredentials: true,
        })
        .then(function(result) {
            User.current = result
        })
    }
}

module.exports = User
</code></pre>
<p>Notice we added a <code>User.current</code> property, and a <code>User.load(id)</code> method which populates that property. We can now populate the <code>UserForm</code> view using this new method:</p>
<pre><code class=language-javascript>// src/views/UserForm.js
var m = require(&quot;mithril&quot;)
var User = require(&quot;../models/User&quot;)

module.exports = {
    oninit: function(vnode) {User.load(vnode.attrs.id)},
    view: function() {
        return m(&quot;form&quot;, [
            m(&quot;label.label&quot;, &quot;First name&quot;),
            m(&quot;input.input[type=text][placeholder=First name]&quot;, {value: User.current.firstName}),
            m(&quot;label.label&quot;, &quot;Last name&quot;),
            m(&quot;input.input[placeholder=Last name]&quot;, {value: User.current.lastName}),
            m(&quot;button.button[type=submit]&quot;, &quot;Save&quot;),
        ])
    }
}
</code></pre>
<p>Similar to the <code>UserList</code> component, <code>oninit</code> calls <code>User.load()</code>. Remember we had a route parameter called <code>:id</code> on the <code>&quot;/edit/:id&quot;: UserForm</code> route? The route parameter becomes an attribute of the <code>UserForm</code> component&#39;s vnode, so routing to <code>/edit/1</code> would make <code>vnode.attrs.id</code> have a value of <code>&quot;1&quot;</code>.</p>
<p>Now, let&#39;s modify the <code>UserList</code> view so that we can navigate from there to a <code>UserForm</code>:</p>
<pre><code class=language-javascript>// src/views/UserList.js
var m = require(&quot;mithril&quot;)
var User = require(&quot;../models/User&quot;)

module.exports = {
    oninit: User.loadList,
    view: function() {
        return m(&quot;.user-list&quot;, User.list.map(function(user) {
            return m(m.route.Link, {
                class: &quot;user-list-item&quot;,
                href: &quot;/edit/&quot; + user.id,
            }, user.firstName + &quot; &quot; + user.lastName)
        }))
    }
}
</code></pre>
<p>Here we swapped out the <code>.user-list-item</code> vnode with an <code>m.route.Link</code> with that class and the same children. We added an <code>href</code> that references the route we want. What this means is that clicking the link would change the part of URL that comes after the hashbang <code>#!</code> (thus changing the route without unloading the current HTML page). Behind the scenes, it uses an <code>&lt;a&gt;</code> to implement the link, and it all just works.</p>
<p>If you refresh the page in the browser, you should now be able to click on a person and be taken to a form. You should also be able to press the back button in the browser to go back from the form to the list of people.</p>
<hr>
<p>The form itself still doesn&#39;t save when you press &quot;Save&quot;. Let&#39;s make this form work:</p>
<pre><code class=language-javascript>// src/views/UserForm.js
var m = require(&quot;mithril&quot;)
var User = require(&quot;../models/User&quot;)

module.exports = {
    oninit: function(vnode) {User.load(vnode.attrs.id)},
    view: function() {
        return m(&quot;form&quot;, {
                onsubmit: function(e) {
                    e.preventDefault()
                    User.save()
                }
            }, [
            m(&quot;label.label&quot;, &quot;First name&quot;),
            m(&quot;input.input[type=text][placeholder=First name]&quot;, {
                oninput: function (e) {User.current.firstName = e.target.value},
                value: User.current.firstName
            }),
            m(&quot;label.label&quot;, &quot;Last name&quot;),
            m(&quot;input.input[placeholder=Last name]&quot;, {
                oninput: function (e) {User.current.lastName = e.target.value},
                value: User.current.lastName
            }),
            m(&quot;button.button[type=submit]&quot;, &quot;Save&quot;),
        ])
    }
}
</code></pre>
<p>We added <code>oninput</code> events to both inputs, that set the <code>User.current.firstName</code> and <code>User.current.lastName</code> properties when a user types.</p>
<p>In addition, we declared that a <code>User.save</code> method should be called when the &quot;Save&quot; button is pressed. Let&#39;s implement that method:</p>
<pre><code class=language-javascript>// src/models/User.js
var m = require(&quot;mithril&quot;)

var User = {
    list: [],
    loadList: function() {
        return m.request({
            method: &quot;GET&quot;,
            url: &quot;https://rem-rest-api.herokuapp.com/api/users&quot;,
            withCredentials: true,
        })
        .then(function(result) {
            User.list = result.data
        })
    },

    current: {},
    load: function(id) {
        return m.request({
            method: &quot;GET&quot;,
            url: &quot;https://rem-rest-api.herokuapp.com/api/users/&quot; + id,
            withCredentials: true,
        })
        .then(function(result) {
            User.current = result
        })
    },

    save: function() {
        return m.request({
            method: &quot;PUT&quot;,
            url: &quot;https://rem-rest-api.herokuapp.com/api/users/&quot; + User.current.id,
            body: User.current,
            withCredentials: true,
        })
    }
}

module.exports = User
</code></pre>
<p>In the <code>save</code> method at the bottom, we used the <code>PUT</code> HTTP method to indicate that we are upserting data to the server.</p>
<p>Now try editing the name of a user in the application. Once you save a change, you should be able to see the change reflected in the list of users.</p>
<hr>
<p>Currently, we&#39;re only able to navigate back to the user list via the browser back button. Ideally, we would like to have a menu - or more generically, a layout where we can put global UI elements</p>
<p>Let&#39;s create a file <code>src/views/Layout.js</code>:</p>
<pre><code class=language-javascript>// src/views/Layout.js
var m = require(&quot;mithril&quot;)

module.exports = {
    view: function(vnode) {
        return m(&quot;main.layout&quot;, [
            m(&quot;nav.menu&quot;, [
                m(m.route.Link, {href: &quot;/list&quot;}, &quot;Users&quot;)
            ]),
            m(&quot;section&quot;, vnode.children)
        ])
    }
}
</code></pre>
<p>This component is fairly straightforward, it has a <code>&lt;nav&gt;</code> with a link to the list of users. Similar to what we did to the <code>/edit</code> links, this link uses <code>m.route.Link</code> to create a routable link.</p>
<p>Notice there&#39;s also a <code>&lt;section&gt;</code> element with <code>vnode.children</code> as children. <code>vnode</code> is a reference to the vnode that represents an instance of the Layout component (i.e. the vnode returned by a <code>m(Layout)</code> call). Therefore, <code>vnode.children</code> refer to any children of that vnode.</p>
<p>And let&#39;s update the styles once more:</p>
<pre><code class=language-css>/* styles.css */
body, .input, .button {
    font: normal 16px Verdana;
    margin: 0;
}

.layout {
    margin: 10px auto;
    max-width: 1000px;
}

.menu {
    margin: 0 0 30px;
}

.user-list {
    list-style: none;
    margin: 0 0 10px;
    padding: 0;
}

.user-list-item {
    background: #fafafa;
    border: 1px solid #ddd;
    color: #333;
    display: block;
    margin: 0 0 1px;
    padding: 8px 15px;
    text-decoration: none;
}

.user-list-item:hover {
    text-decoration: underline;
}

.label {
    display: block;
    margin: 0 0 5px;
}

.input {
    border: 1px solid #ddd;
    border-radius: 3px;
    box-sizing: border-box;
    display: block;
    margin: 0 0 10px;
    padding: 10px 15px;
    width: 100%;
}

.button {
    background: #eee;
    border: 1px solid #ddd;
    border-radius: 3px;
    color: #333;
    display: inline-block;
    margin: 0 0 10px;
    padding: 10px 15px;
    text-decoration: none;
}

.button:hover {
    background: #e8e8e8;
}
</code></pre>
<p>Let&#39;s change the router in <code>src/index.js</code> to add our layout into the mix:</p>
<pre><code class=language-javascript>// src/index.js
var m = require(&quot;mithril&quot;)

var UserList = require(&quot;./views/UserList&quot;)
var UserForm = require(&quot;./views/UserForm&quot;)
var Layout = require(&quot;./views/Layout&quot;)

m.route(document.body, &quot;/list&quot;, {
    &quot;/list&quot;: {
        render: function() {
            return m(Layout, m(UserList))
        }
    },
    &quot;/edit/:id&quot;: {
        render: function(vnode) {
            return m(Layout, m(UserForm, vnode.attrs))
        }
    },
})
</code></pre>
<p>We replaced each component with a <a href=route.html#routeresolver>RouteResolver</a> (basically, an object with a <code>render</code> method). The <code>render</code> methods can be written in the same way as regular component views would be, by nesting <code>m()</code> calls.</p>
<p>The interesting thing to pay attention to is how components can be used instead of a selector string in a <code>m()</code> call. Here, in the <code>/list</code> route, we have <code>m(Layout, m(UserList))</code>. This means there&#39;s a root vnode that represents an instance of <code>Layout</code>, which has a <code>UserList</code> vnode as its only child.</p>
<p>In the <code>/edit/:id</code> route, there&#39;s also a <code>vnode</code> argument that carries the route parameters into the <code>UserForm</code> component. So if the URL is <code>/edit/1</code>, then <code>vnode.attrs</code> in this case is <code>{id: 1}</code>, and this <code>m(UserForm, vnode.attrs)</code> is equivalent to <code>m(UserForm, {id: 1})</code>. The equivalent JSX code would be <code>&lt;UserForm id={vnode.attrs.id} /&gt;</code>.</p>
<p>Refresh the page in the browser and now you&#39;ll see the global navigation on every page in the app.</p>
<hr>
<p>This concludes the tutorial.</p>
<p>In this tutorial, we went through the process of creating a very simple application where we can list users from a server and edit them individually. As an extra exercise, try to implement user creation and deletion on your own.</p>
<p>If you want to see more examples of Mithril.js code, check the <a href=examples.html>examples</a> page. If you have questions, feel free to drop by the <a href=https://mithril.zulipchat.com/ >Mithril.js chat room</a>.</p>
<hr>
<small>License: MIT. &copy; Leo Horie.</small>
</section>
</main>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-jsx.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-diff.min.js></script>
<script src=https://unpkg.com/mithril@2.2.2/mithril.js async></script>
<script src=https://flems.io/flems.html id=flems defer></script>
<script>
document.querySelector(".hamburger").onclick = function() {
			document.body.className = document.body.className === "navigating" ? "" : "navigating"
			document.querySelector("h1 + ul").onclick = function() {
				document.body.className = ''
			}
		}
		document.getElementById("flems").onload = function() {
			var systemFonts = [
				"body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; }",
				"body { height: 100%; overflow:hidden; display:flex; justify-content: center; align-items:center; }"
			].join("")
			;[].forEach.call(document.querySelectorAll("pre code.language-js"), function(el) {
				el = el.parentNode

				var div = document.createElement("div")
				window.Flems(div, {
					middle        : 60,
					editable      : true,
					toolbar       : false,
					shareButton   : true,
					console       : false,
					autoHeight    : true,
					files: [{
						name: ".js",
						content: el.textContent
					}, {
						name: ".css",
						content: systemFonts
					}],
					links: [{
						name: "mithril",
						type: "script",
						url: "https://unpkg.com/mithril@2.2.2/mithril.js"
					}]
				}, "https://flems.io/flems.html")

				el.parentNode.insertBefore(div, el)
				el.parentNode.removeChild(el)
			})
		}
</script>
